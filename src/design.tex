\section{Design}\label{sec:design}
To make sense of the research landscape in the area of firmware analysis and identify potentially interesting areas for further research, we must be able to make quantitative observations about existing research.
To achieve this, we opt for a classification-based approach, where we place each piece of research into one or more categories across several variables.

There are numerous ways to classify such research.
\textcite{muench2018what} provide one option.\todo{Explain!}
\textcite{costin2014large} provide another.\todo{Explain!}
However, these classification systems were not adequate for our study, because of reasons.\todo{What reasons?}
Therefore, we developed our own classification, across several variables: firmware types, analysis types, scraping approaches, device types, instruction set architecture, whether and where the data set is available, and what parts of the firmware the studies analyzed.
Except for data set availability, these are multi-valued variables; i.e. the categories for each variable are not mutually exclusive.
We also collected numerical data about the number of samples that were initially retrieved, and how many were actually used in analysis (after any preliminary filtering).

We split the firmware into two types: Linux-based (LB), and non-Linux-based (NLB).
LB firmware is designed to execute on top of an operating system that is based on the Linux kernel.
NLB firmware either executes on top of a different operating system (e.g. VxWorks), or has no OS abstraction whatsoever.
A study can be labeled as both LB and NLB, if it analyzes both types of firmware.

The ``analysis types'' category captures the style of analysis that the research in question conducted.
It indicates whether the authors performed static analysis, dynamic analysis, symbolic execution, or a combination of the three.
It also shows whether the study included taint tracking.

The ``scraping approaches'' category contains the methods that the authors of a particular source used to retrieve firmware samples.
This could mean downloading them from vendors' websites or FTP servers, using an app-based approach, using a custom search engine (such as the one offered by Google\footnote{\url{https://programmablesearchengine.google.com/about/}}), extracting them directly from the devices, compiling them from source code, or allowing users to submit firmware for analysis.
Some studies reused existing data sets from previous research, and some did not specify the methods they used.

We opted to separate the devices that were analyzed by sector, i.e. in which area those devices are commonly used.
The `personal' sector contains devices that a single person would use and would carry with them (e.g. wearable, phone, tablet, smart eyeglasses).
The `IoT' (Internet of Things) sector includes various internet-connected devices that a person would place in their home or on their belongings (e.g. tag, printer, car accessory, bike accessory, switch, smart lock, smart light, thermometer, alarm, IP camera, routers and access points, network-attached storage, smart meter, CCTV, Zigbee, ADSL gateway).
The `computer peripherals' sector contains components of computers, or devices intended to be used with a computer (e.g. device drivers, bootloader, battery, storage devices, network interface card, Logitech mouse, Apple keyboard).
The `industrial' sector includes devices used for manufacturing or control in industry (milling controller, programmable logic controller, reflow oven, console, steering control for a self-driving vehicle, soldering iron, heat press, agricultural equipment).
Finally, there is a `medical' sector for devices used in medical contexts, and an `other' sector for devices that do not fit in the other categories (e.g. drone, self-balancing robot, card reader, development boards, gateway device, upgrade tool, DSLAM, ISDN server, single board computer).

We also keep track of the instruction set architectures (ISAs) for which the analyzed firmware is intended.
The only coalescing we did in this category was that we grouped various versions of ARM (e.g. ARMv7-Thumb, ARMv8A) under the same ``ARM'' label.
If a paper did not explicitly state the architecture, we researched the specific processors of the devices that the authors used, and noted their architectures.

Furthermore, we noted whether the data set that the authors used is (still) available.
We only considered whether the authors of the paper themselves provided the data set that they used in analysis.
If they used a data set from previous research, but did not provide a copy of the data set as \textit{they} used it, this is not sufficient; it is not guaranteed that the currently available version of that previously compiled data set is the same as the version that the authors used.

Finally, we kept track of the parts of firmware that the papers analyzed.
Some research analyzed the actual code of the firmware; some only the configuration or credentials stored in the firmware.
Other papers analyzed the interfaces of the firmware -- that is, they interacted with the methods that the firmware uses to communicate with the `outside world' (e.g. web interfaces, ports, protocols).
